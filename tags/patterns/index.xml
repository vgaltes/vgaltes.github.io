<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Patterns on VGALTES blog</title>
    <link>http://example.org/tags/patterns/</link>
    <description>Recent content in Patterns on VGALTES blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 29 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://example.org/tags/patterns/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Lambda destinations</title>
      <link>http://example.org/post/lambda-destinations/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/lambda-destinations/</guid>
      <description>AWS recently introduced lambda destinations for asynchronous invocations. So, if you have, let&amp;rsquo;s say, a lambda function attached to an SNS event, you can configure a destination when the execution is successful and a destination when the execution fails. The destination can be either an SQS queue, an SNS topic, EventBridge or another Lambda function.
As usual, the serverless framework implemented this feature quickly. Let&amp;rsquo;s take a look how to do it and what&amp;rsquo;s the difference with a DLQ.</description>
    </item>
    
    <item>
      <title>Serverless Patterns implemented: using an SQS queue as a DLQ for a SNS topic</title>
      <link>http://example.org/post/serverless-patterns-implemented-sls-dlq/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/serverless-patterns-implemented-sls-dlq/</guid>
      <description>In the last two articles (here and here) we implemented some of the Serverless Patterns described in this article from Jeremy Daly. In this article, we&amp;rsquo;re going to concentrate in just one pattern, the Notifier. We&amp;rsquo;re going to do this, because of the [recent announcement] from AWS that you can now use an SQS queue as a Dead Letter Queue for an SNS topic.
If you read the article, you will see that this DLQ is complementary to the DLQ you might define in a function that is triggered by an SNS topic, as Otavio Ferreira explains here.</description>
    </item>
    
    <item>
      <title>Serverless Patterns implemented, part 2</title>
      <link>http://example.org/post/serverless-patterns-implemented-part2/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/serverless-patterns-implemented-part2/</guid>
      <description>In this article I will continue with the implementation of some Serverless Patterns described in this article from Jeremy Daly about [Serverless Patterns]. Check the first post here Let&amp;rsquo;s start!
Common setup All the projects will have a common setup, which is fairly simple. First, initialize a NodeJS project:
yarn init  Then install the serverless framework as a dev dependency
yarn add serverless --dev  And finally create a script to deploy the project</description>
    </item>
    
    <item>
      <title>Serverless Patterns implemented, part 1</title>
      <link>http://example.org/post/serverless-patterns-implemented-part1/</link>
      <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/serverless-patterns-implemented-part1/</guid>
      <description>I think that the best way to learn something is to practice it and to try to explain it, so this is what I&amp;rsquo;m going to do in the next series of posts. These posts will be based on the amazing article from Jeremy Daly about Serverless Patterns. I&amp;rsquo;m not going to copy Jeremy&amp;rsquo;s words here, so for each pattern, go to the article and read it. I&amp;rsquo;ll provide a technical implementation here and I will mention more resources I found interesting.</description>
    </item>
    
  </channel>
</rss>